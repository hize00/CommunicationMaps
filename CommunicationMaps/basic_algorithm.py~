from copy import deepcopy
import math
import os
import pickle
import random
import sys
import threading

#import rospy
import actionlib
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal, MoveBaseFeedback
from actionlib_msgs.msg import *
from geometry_msgs.msg import Point, Twist, Vector3, PoseWithCovarianceStamped, PoseStamped
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import Path
from std_srvs.srv import Empty
from std_msgs.msg import Float32, Bool

import communication
from environment import Environment
import exploration_strategies
from GPmodel import GPmodel
import utils
from utils import conv_to_hash, eucl_dist
from strategy.msg import GoalWithBackup, SignalData, RobotInfo, AllInfo, SignalMappingAction, \
                               SignalMappingGoal, SignalMappingFeedback, SignalMappingResult
from strategy.srv import GetSignalData, GetSignalDataResponse

N_ROBOTS=4  

###################################################################################################


class Cell:
	def __init__(self, robot, vertex):
		self.robot = robot
		self.vertex = vertex

class Configuration:
	def __init__(self, 



class GenericRobot(object):
    def __init__(self, seed, robot_id, is_leader, sim, comm_range, map_filename, polling_signal_period, duration, 
                 log_filename, comm_dataset_filename, teammates_id, n_robots, ref_dist, strategy, resize_factor, errors_filename, client_topic='move_base'):
        self.seed = seed        
        random.seed(seed + robot_id)
        self.robot_id = robot_id
        self.is_leader = is_leader
        self.teammates_id = teammates_id
        self.n_robots = n_robots
        self.polling_signal_period = polling_signal_period
        
        self.strategy_error_log = strategy
        self.map_filename = map_filename

        self.strategy = strategy

        self.tol_dist = 2.5
        self.errors_filename = errors_filename
        self.error_count = 0

        self.sim = sim



class Random(GenericRobot):
    def __init__(self, seed, robot_id, sim, comm_range, map_filename, polling_signal_period, duration, 
                 disc_method, disc, log_filename, teammates_id, n_robots, ref_dist, env_filename, 
                 comm_dataset_filename, strategy, resize_factor, tiling, errors_filename):
        rospy.loginfo(str(robot_id) + ' - Random - starting!')

        if(not(os.path.exists(env_filename))):
            f = open(env_filename, "wb")
            self.env = Environment(map_filename, disc_method, disc, resize_factor, comm_range)
            pickle.dump(self.env, f)
            f.close()
        else:
            f = open(env_filename, "rb")
            self.env = pickle.load(f)
            f.close()

        
        super(Random, self).__init__(seed, robot_id, True, sim, comm_range, map_filename, polling_signal_period, 
                                     duration, log_filename, comm_dataset_filename, teammates_id, n_robots, 
                                     ref_dist, strategy, resize_factor, errors_filename)


        self.replan_rate = REPLAN_RATE
        self.arrived_to_random_pos = True

    def explore_comm_maps(self):
        r = rospy.Rate(self.replan_rate) 
        while not rospy.is_shutdown():
            if(self.arrived_to_random_pos):
                self.arrived_to_random_pos = False
                new_dest = random.choice(self.env.free_positions)
                rospy.loginfo(str(self.robot_id) + ' chosen new dest: ' + str(new_dest))
                t = threading.Thread(target=self.send_to_light, args=(new_dest, ))
                t.start()
            
            r.sleep()

    def send_to_light(self, target):
        rospy.loginfo(str(self.robot_id) + ' moving to ' + str(target))
        goal = MoveBaseGoal()
        goal.target_pose.header.frame_id='/map'
        goal.target_pose.pose.position.x = target[0]
        goal.target_pose.pose.position.y = target[1]
        goal.target_pose.pose.orientation.w = 1
        self.client_motion.send_goal(goal, feedback_cb = self.feedback_motion_cb)
        self.client_motion.wait_for_result()
        state = self.client_motion.get_state()
        rospy.loginfo(str(self.robot_id) + ' stopped motion with state ' + str(state))
        if(state == GoalStatus.PREEMPTED):
            self.clear_costmap_service()
            self.motion_recovery()
            self.clear_costmap_service()
        elif(state == GoalStatus.ABORTED):
            if self.sim:
                self.bump_bkw()
            else:
                self.clear_costmap_service()
                self.motion_recovery()
                self.clear_costmap_service()
            
        self.arrived_to_random_pos = True
                    




